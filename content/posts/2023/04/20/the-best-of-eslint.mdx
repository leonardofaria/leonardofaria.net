---
id: 2239
title: The best of ESLint
publishedAt: 2023-04-20:12:00:00-08:00
type: Post
permalink: /2023/04/20/the-best-of-eslint
description: (Almost) everything you want to know about ESLint
---

Have you ever asked yourself how ESLint works and what we can do with it? Why do we have so many rules and which ones are the best, most helpful ones? In this post, you will learn one thing or two about this linter and its rules.

## Intro

A linter is a tool that statically analyzes your code and based on their rules, reports warnings and errors. Linters are helpful to catch bugs and enforce standards in a codebase.

ESLint is the most popular JavaScript linter these days but it is not the only one: [JSHint](https://jshint.com) was a popular tool in the past and [Rome](https://rome.tools) is a promising tool that accomplishes similar goals.

### But, how exactly?

We can not talk about linters without talking about AST (Abstract Syntax Trees). AST is a JavaScript object containing a tree representation of your code. Let's use as example a function that sums two numbers:

```js
function sum(a, b) {
  return a + b;
}

sum(1, 2);
```

The AST for the code above will be a three like:

```json
{
  "type": "Program",
  "start": 0,
  "end": 50,
  "body": [
    {
      "type": "FunctionDeclaration",
      "start": 0,
      "end": 38,
      "id": {
        "type": "Identifier",
        "start": 9,
        "end": 12,
        "name": "sum"
      },
      "expression": false,
      "generator": false,
      "async": false,
      "params": [
        {
          "type": "Identifier",
          "start": 13,
          "end": 14,
          "name": "a"
        },
        {
          "type": "Identifier",
          "start": 16,
          "end": 17,
          "name": "b"
        }
      ],
      "body": {
        "type": "BlockStatement",
        "start": 19,
        "end": 38,
        "body": [
          {
            "type": "ReturnStatement",
            "start": 23,
            "end": 36,
            "argument": {
              "type": "BinaryExpression",
              "start": 30,
              "end": 35,
              "left": {
                "type": "Identifier",
                "start": 30,
                "end": 31,
                "name": "a"
              },
              "operator": "+",
              "right": {
                "type": "Identifier",
                "start": 34,
                "end": 35,
                "name": "b"
              }
            }
          }
        ]
      }
    },
    {
      "type": "ExpressionStatement",
      "start": 40,
      "end": 50,
      "expression": {
        "type": "CallExpression",
        "start": 40,
        "end": 49,
        "callee": {
          "type": "Identifier",
          "start": 40,
          "end": 43,
          "name": "sum"
        },
        "arguments": [
          {
            "type": "Literal",
            "start": 44,
            "end": 45,
            "value": 1,
            "raw": "1"
          },
          {
            "type": "Literal",
            "start": 47,
            "end": 48,
            "value": 2,
            "raw": "2"
          }
        ],
        "optional": false
      }
    }
  ],
  "sourceType": "module"
}
```

The parser is smart enough to ignore spaces and things that don't matter: `console.log('Hello')` and `console.log(    'Hello'    )` are the same. A linter will analyze the object and report warnings and errors according to its rules. For example, a linter can scan this code and report that we should not have a function called `sum`.

![AST](/wp-content/uploads/2023/04/ast.svg)

You can use a website like [AST Explorer](https://astexplorer.net) to create a object of your code or [jointJS JavaScript AST Visualiser](https://www.jointjs.com/demos/abstract-syntax-tree) to create the chart above.

Once we have the parseable content, we can analyze it and ditch what we don't want. Imagine we don't want a function called `sum` and this would be a very simple code to report this:

```js
// Add code
```

Defined the rule, the next step is to define the severity level: `error`, `warning` and `info`.

## Rules and plugins

Once we know which rules we want in place and the severity, we can create or adopt plugins. Plugins extend ESLint with custom rules or an opinated way to write JavaScript.

Let's take for example `eslint-config-airbnb`, a very popular package. They have adopt a set of rules they understand as [best practices](https://github.com/airbnb/javascript/blob/master/packages/eslint-config-airbnb-base/rules/best-practices.js) and reflect the [style](https://github.com/airbnb/javascript/blob/master/packages/eslint-config-airbnb-base/rules/style.js) of JavaScript code they want in their applications.

Here is part of the [`styles.js`](https://github.com/airbnb/javascript/blob/master/packages/eslint-config-airbnb-base/rules/style.js), let's check these 2 rules:

```js
module.exports = {
  rules: {
    // ...many rules

    // require camel case names
    camelcase: ['error', { properties: 'never', ignoreDestructuring: false }],

    // specify the maximum length of a line in your program
    // https://eslint.org/docs/rules/max-len
    'max-len': [
      'error',
      100,
      2,
      {
        ignoreUrls: true,
        ignoreComments: false,
        ignoreRegExpLiterals: true,
        ignoreStrings: true,
        ignoreTemplateLiterals: true,
      },
    ],
  },
};
```

If you are using their plugin in your app, an error will be reported with you create a variable called `number_of_items`, and you should use `numberOfItems` instead. Your code should not have more than 100 characters per line, except for the cases defined in the options object.

## Useful plugins to adopt

You don't need to be an ESLint or JavaScript expert to decide which rules to adopt, you can basically adopt one or more plugins created by the community and you will write a better, more consistent code. Here are some of the more popular ones:

### eslint-plugin-import

[eslint-plugin-import](https://www.npmjs.com/package/eslint-plugin-import) helps with all ES2015+ import/export syntax.

### eslint-plugin-react

[eslint-plugin-react](https://www.npmjs.com/package/eslint-plugin-react) gives you a set of rules to write better/clear/modern React code.

### eslint-plugin-react-hooks

### eslint-plugin-jsx-a11y

### eslint-config-airbnb

### eslint-config-airbnb-base

### TYPESCRIPT

### eslint-config-prettier

### eslint-config-relay

### eslint-config-next

This is only helpful if you have a Next.js application. It already extends `eslint-plugin-react`, `eslint-plugin-react-hooks`, `eslint-plugin-jsx-a11y` and add some rules to enforce Next.js features, like using their `<Image>` component instead of `<img>` HTML tags.

(things like import order)

## Creating your own set of recommended rules

Instead of manually adding all these plugins in all your different codebases, you can do like Airbnb or Next.js and create your own config file that extends recommend rules from other packages.

In the past I created a package called `eslint-config-leozera` which extends `eslint-plugin-import`, `eslint-plugin-react`, `eslint-plugin-react-hooks`, `eslint-plugin-jsx-a11y` and overrides some of their configs.

The source-code of my project is a good start if you are looking at creating a package for different apps of your company for example.

## Helpful and/or curious rules to use

The following rules are not enabled by default in any of recommended plugins above:

## References

Some posts I'm based on to write this post:

- https://www.nearform.com/blog/what-is-an-abstract-syntax-tree/
- https://www.jointjs.com/demos/abstract-syntax-tree
- https://stackoverflow.com/questions/16127985/what-is-javascript-ast-how-to-play-with-it
- https://jotadeveloper.medium.com/abstract-syntax-trees-on-javascript-534e33361fc7
- https://www.digitalocean.com/community/tutorials/js-traversing-ast
